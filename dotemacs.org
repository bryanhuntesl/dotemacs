Load this file with:

: (require 'org-loaddefs)
: (org-babel-load-file "~/dotemacs/dotemacs.org")

The contents of this file may be modified and/or redistributed
according to the terms of the [[http://www.wtfpl.net/][WTFPL]].

* Set up org-capture and bind it to F8
#+BEGIN_SRC emacs-lisp
  (require 'org-capture)

  (defvar my-org-current-file "~/org/notes.org"
    "The file where new activities are started.")

  (defun my-org-capture-current-file ()
    (set-buffer (org-capture-target-buffer my-org-current-file))
    ;; Now we need to move somewhere that's not a headline...
    (goto-char (point-min))
    (unless (org-at-heading-p)
      (outline-next-heading))
    (when (org-at-heading-p)
      (insert "\n"))
    ;; (goto-char (point-max))
    ;; (or (bolp) (insert "\n"))
    ;; (insert "* \n")
    ;; (beginning-of-line 0)
    ;; (while (and (org-at-heading-p) (not (bobp)))
    ;;   (forward-line -1))
    )

  (defun my-org-set-current-file (new-file)
    (interactive
     (let ((dir "~/org/"))
       (list
        (expand-file-name (read-file-name "New org file for captures: "
                                          dir nil t nil (lambda (f) (string-match-p "\\.org$" f)))
                          dir))))
    (setq my-org-current-file new-file))

  (add-to-list 'org-capture-templates '("n" "Note" entry (clock) "* %^{Note title} %T\n%?"))
  (add-to-list 'org-capture-templates '("4" "New activity" entry (function my-org-capture-current-file) "* %^{New activity}\n%?\n%a" :prepend t :clock-in t))
  (add-to-list 'org-capture-templates '("e" "dotemacs" entry (file "~/dotemacs/dotemacs.org") "* %^{dotemacs snippet titled}\nAdded on %U.\n#+BEGIN_SRC emacs-lisp\n  %?\n#+END_SRC" :unnarrowed))
  (add-to-list 'org-capture-templates '("l" "List item from active region" item (clock) "- %i\n" :immediate-finish t))
  (global-set-key [f8] 'org-capture)
  (global-set-key [S-f8] 'org-capture-goto-last-stored)
#+END_SRC
* Useful key bindings
** Bind C-c c to compile+reload emacs lisp file
#+BEGIN_SRC emacs-lisp
  (eval-after-load "lisp-mode"
    '(progn
       (define-key emacs-lisp-mode-map (kbd "C-c c") 'emacs-lisp-byte-compile-and-load)))
#+END_SRC
** Bind `l' to "back" in help mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'help-mode-hook
            (lambda () (local-set-key "l" 'help-go-back)))
#+END_SRC
** Bind C-backspace to bury-buffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-<backspace>") 'bury-buffer)
#+END_SRC
** Bind super-i to imenu
#+BEGIN_SRC emacs-lisp
  (global-set-key [(super ?i)] 'imenu)
#+END_SRC
** Bind PrintScreen to various compile commands
#+BEGIN_SRC emacs-lisp
  (global-set-key [print] 'recompile)
  (global-set-key [(shift print)] 'compile)
  ;; On my macbook, PrintScreen is called F13...
  (global-set-key [f13] 'recompile)
  (global-set-key [(shift f13)] 'compile)
#+END_SRC
** Switch windows with C-s-up and C-s-down
#+BEGIN_SRC emacs-lisp
  (defun other-window-backwards ()
    (interactive)
    (other-window -1))
  
  (global-set-key [(control super down)] 'other-window)
  (global-set-key [(control super up)] 'other-window-backwards)
#+END_SRC
** Scroll line by line with s-up and s-down
#+BEGIN_SRC emacs-lisp
  (defun scroll-down-one-line ()
    "Scroll down one line."
    (interactive)
    (scroll-down 1))
  
  (defun scroll-up-one-line ()
    "Scroll up one line."
    (interactive)
    (scroll-up 1))
  
  (global-set-key [(super up)] 'scroll-down-one-line)
  (global-set-key [(super down)] 'scroll-up-one-line)
#+END_SRC
** org-agenda is s-a
#+BEGIN_SRC emacs-lisp
  (global-set-key [(super ?a)] 'org-agenda)
#+END_SRC
** Bind M-/ to hippie-expand
#+BEGIN_SRC emacs-lisp
  (global-set-key [(meta ?/)] 'hippie-expand)
#+END_SRC
** Bind C-c l to org-store-link
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-cl" 'org-store-link)
#+END_SRC
** Bind s-l to find-library
#+BEGIN_SRC emacs-lisp
  (global-set-key [(super l)] 'find-library)
#+END_SRC
** Bind C-c f to find-function
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c f") 'find-function)
#+END_SRC
** Various keys for opening URL at point in Firefox
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-<kp-5>") 'browse-url-firefox)
  (global-set-key (kbd "s-<kp-begin>") 'browse-url-firefox)
  (global-set-key (kbd "s-t") 'browse-url-firefox)
#+END_SRC
** EMMS key bindings
#+BEGIN_SRC emacs-lisp
  (global-set-key [Scroll_Lock] 'emms-pause)
  (global-set-key (kbd "<S-Scroll_Lock>") 'emms-next)
  (global-set-key (kbd "<C-Scroll_Lock>") 'emms-show)
  
  ;; Also use F12, for when scroll lock is not available
  (global-set-key [f12] 'emms-pause)
  (global-set-key (kbd "<S-f12>") 'emms-next)
  (global-set-key (kbd "<C-f12>") 'emms-show)
#+END_SRC
** F9 for org-clock-goto
#+begin_src emacs-lisp
  (global-set-key [f9] 'org-clock-goto)
  ;; Also C-f9, if the Mac wants to steal plain f9.
  (global-set-key (kbd "<C-f9>") 'org-clock-goto)
#+end_src

** Clock in recent task with F7
#+BEGIN_SRC emacs-lisp
  (defun org-clock-in-menu ()
    (interactive)
    (org-clock-in (list 4)))
  (global-set-key [f7] 'org-clock-in-menu)
#+END_SRC

** s-SPC for ace-jump
See https://github.com/winterTTr/ace-jump-mode/

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "s-SPC") 'ace-jump-mode)
#+END_SRC

** s-r is rgrep
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "s-r") 'rgrep)
#+END_SRC
** s-m is magit-status
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "s-m") 'magit-status)
#+END_SRC
** C-x C-b is for switching buffers
Added on [2014-03-07 Fri 16:50].

I keep pressing this when I mean =C-x b=.
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-x\C-b" 'ido-switch-buffer)
#+END_SRC
** ยง is backward-kill-word
Added on [2014-04-07 Mon 15:11].

I'm not using it for anything else, so...
#+BEGIN_SRC emacs-lisp
  (global-set-key "ยง" 'backward-kill-word)
#+END_SRC
** C-h C-c is C-h c
Added on [2014-07-01 Tue 15:52].

I keep hitting C-h C-c (=describe-copying=) when I mean C-h c
(=describe-key-briefly=).  Let's rebind:
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "help"
    (define-key help-map "\C-c" 'describe-key-briefly))
#+END_SRC
* multiple-cursors
Added on [2013-05-29 Wed 12:31].
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-s->") 'mc/skip-to-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
#+END_SRC
* Toggle full screen
Added on [2013-09-11 Wed 17:59].

Stolen from http://www.emacswiki.org/emacs/FullScreen#toc25.  +Why is
this not part of Emacs?+ This is available as
=toggle-frame-fullscreen= as of Emacs 24.4.
#+BEGIN_SRC emacs-lisp :tangle no
(defun toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
     nil 'fullscreen
     (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))
#+END_SRC

* Erlang stuff
** compilation-error-regexp-alist hack for eunit
Added on [2012-06-25 Mon 11:07].

#+begin_src emacs-lisp
(require 'compile)
#+end_src

Hm, the format string thing doesn't seem to work...
See http://debbugs.gnu.org/cgi/bugreport.cgi?bug=11777 .
#+BEGIN_SRC emacs-lisp :results output silent
  (setq compilation-error-regexp-alist-alist
        (delq (assq 'erlang-eunit compilation-error-regexp-alist-alist)
              compilation-error-regexp-alist-alist))
  (add-to-list
   'compilation-error-regexp-alist-alist
   (cons
    'erlang-eunit
    (list
     "^ *\\(\\([^.:( \t\n]+\\):\\([0-9]+\\)\\):.*\\.\\.\\.\\(?:\\([^*]\\)\\|[*]\\)"
     ;; file
     (list 2 "%s.erl" "src/%s.erl" "test/%s.erl")
     ;; line
     3
     ;; column
     nil
     ;; type - need to match [^*] after the three dots to be info,
     ;; otherwise it's an error
     (cons nil 4)
     ;; highlight
     1
     )))
  (add-to-list 'compilation-error-regexp-alist 'erlang-eunit)
  
#+END_SRC

*** And let's do stacktraces too
#+BEGIN_SRC emacs-lisp :results output silent
  (setq compilation-error-regexp-alist-alist
        (delq (assq 'erlang-eunit-stacktrace compilation-error-regexp-alist-alist)
              compilation-error-regexp-alist-alist))
  (add-to-list
   'compilation-error-regexp-alist-alist
   (cons
    'erlang-eunit-stacktrace
    (list
     "^[ *]*in \\(?:function\\|call from\\) .* [[(]\\(\\([^:,]+\\)\\(?::\\|, line \\)\\([0-9]+\\)\\)[])]$"
     ;; file
     2
     ;; line
     3
     ;; column
     nil
     ;; type
     2
     ;; hyperlink
     1
     )))
  (add-to-list 'compilation-error-regexp-alist 'erlang-eunit-stacktrace)
  
#+END_SRC

*** And assertions
#+BEGIN_SRC emacs-lisp :results output silent
  (setq compilation-error-regexp-alist-alist
        (delq (assq 'erlang-eunit-assert compilation-error-regexp-alist-alist)
              compilation-error-regexp-alist-alist))
  (add-to-list
   'compilation-error-regexp-alist-alist
   (cons
    'erlang-eunit-assert
    (list
     (concat
      "^\\(\\(?:::\\|\\*\\*\\)\\(?:error:\\)?{assert[A-Za-z]+_failed\\),"
      "[ \n]*\\[{module,\\([^}]+\\)},"
      "[ \n]*{line,\\([0-9]+\\)}")
     ;; file
     (list 2 "%s.erl" "src/%s.erl" "test/%s.erl")
     ;; line
     3
     ;; column
     nil
     ;; type
     2
     ;; hyperlink
     1
     )))
  (add-to-list 'compilation-error-regexp-alist 'erlang-eunit-assert)
  
#+END_SRC

*** And raw stacktraces that end up in the output
#+BEGIN_SRC emacs-lisp :results output silent
  (setq compilation-error-regexp-alist-alist
        (delq (assq 'erlang-raw-stacktrace compilation-error-regexp-alist-alist)
              compilation-error-regexp-alist-alist))
  (add-to-list
   'compilation-error-regexp-alist-alist
   (cons
    'erlang-raw-stacktrace
    (list
     "{file,[[:space:]]*\"\\([^\"]+\\)\"},[[:space:]]*{line,[[:space:]]*\\([0-9]+\\)}"
     ;; file
     1
     ;; line
     2
     ;; column
     nil
     ;; type
     2
     ;; hyperlink
     1
     )))
  (add-to-list 'compilation-error-regexp-alist 'erlang-raw-stacktrace)
  
#+END_SRC

*** And let's do lager output (possibly with column numbers) as well
#+BEGIN_SRC emacs-lisp :results output silent
  (setq compilation-error-regexp-alist-alist
        (delq (assq 'erlang-lager-message compilation-error-regexp-alist-alist)
              compilation-error-regexp-alist-alist))
  (add-to-list
   'compilation-error-regexp-alist-alist
   (cons
    'erlang-lager-message
    (list
     "^....-..-.. ..:..:..\\.... \\[\\(?:\\(info\\)\\|[a-z]+\\)\\] <[0-9.]+>@\\([^:]+\\):\\(?:[^:]+\\):{\\([0-9]+\\),\\([0-9]+\\)}"
     ;; file
     (list 2 "%s.erl")
     ;; line
     3
     ;; column
     4
     ;; type
     (cons nil 1)
     ;; hyperlink
     2
     )))
  (add-to-list 'compilation-error-regexp-alist 'erlang-lager-message)
  
#+END_SRC

** Ignore .eunit and .qc in rgrep
Added on [2012-05-30 Wed 16:28].

These directories are created by rebar, and contain complete copies of
the source code in =src/=.  No point in searching through those
directories.
#+BEGIN_SRC emacs-lisp
  (eval-after-load "grep"
    '(progn
       (add-to-list 'grep-find-ignored-directories ".eunit")
       (add-to-list 'grep-find-ignored-directories ".qc")))
#+END_SRC
** rgrep alias for *.[eh]rl
Added on [2010-08-03 Tue 15:08].
#+BEGIN_SRC emacs-lisp
  (eval-after-load "grep"
    '(add-to-list 'grep-files-aliases '("erl" . "*.[eh]rl") :append))
#+END_SRC
** Try harder to find include files in flymake			    :flymake:
#+BEGIN_SRC emacs-lisp
  (defvar mh-erlang-flymake-code-path-dirs (list "../../*/ebin")
    "List of directories to add to code path for Erlang Flymake.
  Wildcards are expanded.")

  (defun mh-simple-get-deps-code-path-dirs ()
    ;; Why complicate things?
    (and (buffer-file-name)
         (let ((default-directory (file-name-directory (buffer-file-name))))
           (apply 'append
                  (mapcar
                   (lambda (wildcard)
                     ;; If the wild card expands to a directory you
                     ;; don't have read permission for, this would throw
                     ;; an error.
                     (ignore-errors
                       (file-expand-wildcards wildcard)))
                   mh-erlang-flymake-code-path-dirs)))))

  (defun mh-simple-get-deps-include-dirs ()
    (list "../include" "../src" ".."))

  (setq erlang-flymake-get-code-path-dirs-function 'mh-simple-get-deps-code-path-dirs
        erlang-flymake-get-include-dirs-function 'mh-simple-get-deps-include-dirs)
#+END_SRC
** Don't warn for exported variables in erlang-flymake		    :flymake:
[2010-12-21 Tue 18:14]
#+begin_src emacs-lisp
  (eval-after-load "erlang-flymake"
    '(setq erlang-flymake-extra-opts
           (delete "+warn_export_vars" erlang-flymake-extra-opts)))
#+end_src
** Flymake: disable GUI warnings, log in message buffer		    :flymake:
Added on [2012-05-25 Fri 12:13].
#+BEGIN_SRC emacs-lisp
  (setq flymake-gui-warnings-enabled nil
        flymake-log-level 0
        )
#+END_SRC
** Be careful about flymake					    :flymake:
Added on [2012-06-25 Mon 16:11].
#+BEGIN_SRC emacs-lisp
  (defun maybe-turn-on-flymake()
    (when (and buffer-file-name (file-name-directory buffer-file-name))
      (unless (file-remote-p buffer-file-name)
        (flymake-mode))))

  (eval-after-load "erlang-flymake"
    '(progn
       (remove-hook 'erlang-mode-hook 'flymake-mode)
       (add-hook 'erlang-mode-hook 'maybe-turn-on-flymake)))

  (eval-after-load "erlang" '(require 'erlang-flymake))
#+END_SRC
** Did you mean underscore?
Added on [2013-12-04 Wed 17:21].
#+BEGIN_SRC emacs-lisp
  (defun erlang-did-you-mean-underscore ()
    "Insert either a hyphen or an underscore.
  Why is it so hard to hold down the shift key when I really want
  an underscore?

  If the word before point consists only of lowercase letters and
  underscores, then I'm probably writing an atom and want an
  underscore.  Otherwise, I'm probably writing a variable name, and
  want a hyphen / minus sign."
    (interactive)
    (let ((case-fold-search nil)
          (parser-state (syntax-ppss)))
      (if (and
           ;; This does not apply to comments.
           (null (nth 4 parser-state))
           ;; Nor to strings.
           (null (nth 3 parser-state))
           (save-match-data (looking-back "\\<[a-z_]+")))
          (progn
            (message "Did you mean underscore?")
            (insert "_"))
        (insert "-"))))

  (eval-after-load "erlang"
    '(define-key erlang-mode-map "-" 'erlang-did-you-mean-underscore))
#+END_SRC

* Org-mode stuff
** Wrap in example tags
Added on [2012-05-21 Mon 15:10].
#+BEGIN_SRC emacs-lisp
  (defun wrap-in-example-tags (beg end)
    (interactive "r")
    (goto-char end)
    (unless (bolp)
      (insert "\n"))
    (insert "#+end_example\n")
    (goto-char beg)
    (unless (bolp)
      (insert "\n"))
    (insert "#+begin_example\n"))
  (eval-after-load "org"
    '(define-key org-mode-map (kbd "C-c e") 'wrap-in-example-tags))
#+END_SRC


* M-x ecd, to open eshell in the specified directory
#+BEGIN_SRC emacs-lisp
  (defun ecd (d)
    (interactive
     (list (expand-file-name (read-directory-name "cd: " nil nil t))))
    (eshell)(eshell/cd d))
#+END_SRC
* diff-mode bindings for magit-commit-mode
Added on [2013-11-11 Mon 16:08].
#+BEGIN_SRC emacs-lisp
  (eval-after-load "magit"
    '(progn
       (define-key magit-commit-mode-map (kbd "C-c C-w") #'diff-tell-file-name)
       (define-key magit-commit-mode-map (kbd "C-c C-a") #'diff-apply-hunk)
       (define-key magit-commit-mode-map (kbd "C-c C-s") #'diff-split-hunk)))
#+END_SRC
* ANSI colours in compilation buffer
Added on [2013-12-10 Tue 10:08].

Inspired by http://stackoverflow.com/a/3072831/113848.
#+BEGIN_SRC emacs-lisp
  (require 'ansi-color)
  (defun colourise-compilation-buffer ()
    ;; grep output gets all red for some reason
    (unless (derived-mode-p 'grep-mode)
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region (point-min) (point-max)))))
  (eval-after-load "compile"
    '(add-hook 'compilation-filter-hook 'colourise-compilation-buffer))
#+END_SRC
* Fix Wingdings in shr
Added on [2013-12-20 Fri 17:05].
#+BEGIN_SRC emacs-lisp
  (defun wingdings-to-unicode (text)
    (let ((mapping '((?J . #x263a)
                     (?K . #x1f610)
                     (?L . #x2639))))
      (cl-map 'string (lambda (c)
                        (or (cdr (assq c mapping))
                            c))
              text)))
  
  (eval-after-load "shr"
    '(defadvice shr-tag-span (around wingdings-to-unicode (cont) activate)
       ;; NB: this will catch wingdings2 too
       (if (let ((case-fold-search t)) (string-match-p "font-family:\s*wingdings" (or (cdr (assq :style cont)) "")))
           (dolist (sub cont)
             (cond
              ((eq (car sub) 'text)
               (shr-insert (wingdings-to-unicode (cdr sub))))
              ((listp (cdr sub))
               (shr-descend sub))))
         ad-do-it)))
#+END_SRC
* Get info from Junit XML files
Added on [2013-12-27 Fri 11:14].

If you run your build with =M-x compile=, and it produces JUnit-style
XML files in one and only one directory, then call
=my-junit-xml-always-display-after-compile= for a summary of the test
results, sorted by most frequent failures.

#+BEGIN_SRC emacs-lisp
  (defvar my-junit-xml-failures ())

  (defun my-junit-xml-read-dir (dir wildcard)
    (interactive (list
                  (read-directory-name "Directory: " nil nil t)
                  (read-string "Wildcard (default *.xml): " nil nil "*.xml")))
    (let* ((default-directory dir)
           (files (file-expand-wildcards wildcard))
           (skipped 0)
           (failure 0))
      (if (null files)
          (user-error "No *.xml files in %s" dir)
        (dolist (file files)
          (let ((root (car (xml-parse-file file)))
                (timestamp (nth 5 (file-attributes file))))
            (cl-labels
                ((read-junit-xml
                  (prefix xml-node)
                  (cl-case (car-safe xml-node)
                    (testsuites
                     ;; Just descend
                     (mapc (apply-partially #'read-junit-xml prefix)
                           (xml-node-children xml-node)))
                    (testsuite
                     (let ((testsuite-name (xml-get-attribute-or-nil xml-node 'name)))
                       (mapc (apply-partially
                              #'read-junit-xml
                              (if testsuite-name
                                  (concat prefix testsuite-name ":")
                                prefix))
                             (xml-node-children xml-node))))
                    (testcase
                     (let* ((name (concat prefix (xml-get-attribute xml-node 'name)))
                            (entry (or (assoc name my-junit-xml-failures)
                                       (list name () ()))))
                       (cond
                        ((or (xml-get-children xml-node 'failure)
                             (xml-get-children xml-node 'error))
                         (incf failure)
                         (cl-pushnew timestamp (second entry) :test 'equal))
                        ((xml-get-children xml-node 'skipped)
                         (incf skipped)
                         (cl-pushnew timestamp (third entry) :test 'equal)))
                       (when (or (second entry) (third entry))
                         (cl-pushnew entry my-junit-xml-failures)))))))
              (mapc (apply-partially #'read-junit-xml nil) (xml-node-children root))))))
      (message "%d failures, %d skipped" failure skipped)))

  (defvar my-junit-xml-latest-display (list 0 0 0)
    "The time when `my-junit-xml-display' was last called.
  We keep this to be able to highlight recent failures.")

  (defun my-junit-xml-display ()
    (interactive)
    (with-current-buffer (get-buffer-create "*junit*")
      (let ((inhibit-read-only t)
            (longest-length 0)
            testcases)
        (erase-buffer)

        (dolist (testcase my-junit-xml-failures)
          (setq longest-length (max longest-length (length (first testcase))))
          (push (list (first testcase)
                      (+ (length (second testcase))
                         (length (third testcase)))
                      (car (sort (append (second testcase) (third testcase))
                                 (lambda (x y) (time-less-p y x)))))
                testcases))

        (setq testcases (sort testcases (lambda (x y)
                                          (or
                                           (> (second x) (second y))
                                           (and (= (second x) (second y))
                                                (time-less-p (third y) (third x)))))))

        (dolist (testcase testcases)
          (let ((text (concat (first testcase) (make-string (- longest-length (length (first testcase))) ?\s) "   "
                              (number-to-string (second testcase)) " failures, "
                              "last on " (format-time-string "%Y-%m-%d %T" (third testcase)) "\n")))
            ;; If this test failed since we last displayed junit
            ;; results, highlight it.
            (when (time-less-p my-junit-xml-latest-display (third testcase))
              (add-text-properties 0 (length text) '(face highlight) text))
            (insert text)))

        (setq my-junit-xml-latest-display (current-time))

        (display-buffer (current-buffer)))))

  (defvar my-junit-xml-dir nil)

  (defvar my-junit-xml-wildcard nil)

  (defun my-junit-xml-always-display-after-compile (dir wildcard)
    "After a compilation finishes, display JUnit info.
  Update from all *.xml files in DIR."
    (interactive (list
                  (read-directory-name "Directory: " nil nil t)
                  (read-string "Wildcard (default *.xml): " nil nil "*.xml")))
    (setq my-junit-xml-dir dir
          my-junit-xml-wildcard wildcard)
    (add-hook 'compilation-finish-functions 'my-junit-xml-after-compilation))

  (defun my-junit-xml-never-display-after-compile ()
    (interactive)
    (remove-hook 'compilation-finish-functions 'my-junit-xml-after-compilation))

  (defun my-junit-xml-after-compilation (compilation-buffer _status)
    (unless (with-current-buffer compilation-buffer
              (derived-mode-p 'grep-mode))
      (my-junit-xml-read-dir my-junit-xml-dir my-junit-xml-wildcard)
      (my-junit-xml-display)))
#+END_SRC
* eval-last-sexp-dwim for C-x C-e
If there are unbound variables, ask for their values.
#+BEGIN_SRC emacs-lisp
  (defun eval-last-sexp-dwim ()
    "Evaluate sexp before point, asking for values of unbound variables."
    (interactive)
    (lexical-let ((sexp (preceding-sexp)))
      (labels
          ((eval-it (the-sexp)
                    (condition-case e
                        (eval the-sexp)
                      (void-variable
                       (lexical-let*
                           ((var (cadr e))
                            (val (car
                                  (read-from-string
                                   (read-from-minibuffer
                                    (format "Value for `%s': " var)))))
                            (new-sexp `(let ((,var ,val))
                                         ,the-sexp)))
                         (eval-it new-sexp))))))
        (message "%S" (eval-it sexp)))))
  (eval-after-load "lisp-mode"
    '(progn
       (define-key emacs-lisp-mode-map (kbd "C-x C-e") 'eval-last-sexp-dwim)))
#+END_SRC
* Pretty lambdas in Lisp modes
#+begin_src emacs-lisp
  ;; stolen from http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda
  (defun pretty-lambdas ()
    (interactive)
    (font-lock-add-keywords
     nil `(("(\\(lambda\\>\\)"
            (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                      ,(make-char 'greek-iso8859-7 107))
                      nil))))))
  (add-hook 'emacs-lisp-mode-hook 'pretty-lambdas)
  (add-hook 'lisp-mode-hook 'pretty-lambdas)
#+end_src
* Auto fill mode in org-capture mode
Added on [2014-01-14 Tue 14:44].
#+BEGIN_SRC emacs-lisp
  (eval-after-load "org-capture"
    '(add-hook 'org-capture-mode-hook 'turn-on-auto-fill))
#+END_SRC
* Convert Libreoffice document to PDF
Added on [2013-06-14 Fri 20:15].
#+BEGIN_SRC emacs-lisp
  (defun my-libreoffice-to-pdf (filename)
    "Convert Libreoffice document to PDF.
  Note that Libreoffice must not be running."
    (interactive "fLibreoffice document to convert to PDF: ")
    (let ((buffer (get-buffer-create "*Libreoffice to PDF*")))
      (unless (zerop
               (call-process
                "/Applications/LibreOffice.app/Contents/MacOS/soffice"
                nil buffer t
                "--headless" "--convert-to" "pdf" filename))
        (message "Conversion failed")
        (display-buffer buffer))))
#+END_SRC
* delete-process-interactively
Added on [2010-08-16 Mon 16:52].
#+BEGIN_SRC emacs-lisp
  (defun delete-process-i(p)(interactive `(,(completing-read"Kill proc: "(mapcar 'process-name(process-list))()t)))(delete-process p))
#+END_SRC
* proced erlang magic
Added on [2014-01-27 Mon 10:53].

Add a filter for viewing only BEAM processes (hit =f= in the proced
buffer and type =beam=):
#+BEGIN_SRC emacs-lisp
  (eval-after-load "proced"
    '(add-to-list 'proced-filter-alist
                  '(beam (comm . "^beam"))))
#+END_SRC

Add an extra field for the node name of the Erlang node:

#+BEGIN_SRC emacs-lisp
  (defun my-proced-erlang-node-name (attrs)
    ;; Proced only displays attributes that are present for the Emacs
    ;; process - so we need to return a non-nil value for non-beam
    ;; processes.
    (cons 'node
          (or
           (when (string-prefix-p "beam" (cdr (assq 'comm attrs)))
             (let ((args (or (cdr (assq 'args attrs))
                             ;; On OSX, process-attributes doesn't return args (yet?)
                             (shell-command-to-string
                              (concat "ps -p " (number-to-string (cdr (assq 'pid attrs)))
                                      " -o args=")))))
               (when (string-match "-s?name \\([^[:space:]]+\\)" args)
                 (match-string 1 args))))
           "")))

  (eval-after-load "proced"
    '(progn
       (add-to-list 'proced-custom-attributes 'my-proced-erlang-node-name)
       (add-to-list 'proced-grammar-alist
                    '(node "Erlang node" "%s" left proced-string-lessp nil (node pid) (nil t nil)))))
#+END_SRC

And add it to a new format config (hit =F= in the proced buffer and
type =erlang=:

#+BEGIN_SRC emacs-lisp
  (eval-after-load "proced"
    '(add-to-list 'proced-format-alist
                  '(erlang user pid tree pcpu pmem start time (args comm) node)))
#+END_SRC
* Set SMTP server depending on From address
Added on [2014-02-21 Fri 14:45].

An amalgamation of various solutions proposed at
http://www.emacswiki.org/emacs/MultipleSMTPAccounts .

#+BEGIN_SRC emacs-lisp
  (defvar my-smtp-servers ()
    "Map e-mail address to SMTP server hostname.
  This is an alist, where the car of each entry is the email
  address of the sender, and the cdr is the SMTP server to use for
  that address.  By default, the port specified in
  `smtpmail-smtp-service' is used, but that can be overridden for
  an individual server by specifying it as \"example.com:42\".

  To set username, add \"machine example.com login foo\" to ~/.authinfo.")

  (with-eval-after-load "smtpmail"
    (defadvice smtpmail-via-smtp (around set-smtp-server-from-header activate)
      (let* ((from-address (save-restriction
                             (message-narrow-to-headers)
                             (mail-fetch-field "from")))
             (server-entry
              (when from-address
                (cdr (assoc-string (cadr
                                    (mail-extract-address-components
                                     from-address))
                                   my-smtp-servers
                                   :ignore-case))))
             (hostname-port
              (when server-entry
                (string-match "^\\([^:]*\\)\\(?::\\([0-9]+\\)\\)?$" server-entry)
                (cons (match-string 1 server-entry) (match-string 2 server-entry))))
             (smtpmail-smtp-server
              (or (and hostname-port (car hostname-port))
                  smtpmail-smtp-server))
             (smtpmail-smtp-service
              (or (and hostname-port (cdr hostname-port) (string-to-number (cdr hostname-port)))
                  smtpmail-smtp-service)))
        (message "Using SMTP server %s:%s" smtpmail-smtp-server smtpmail-smtp-service)
        ad-do-it)))
#+END_SRC
* Fix org-mode-line-clock
  CLOCK: [2014-02-21 Fri 16:28]--[2014-02-21 Fri 16:58] =>  0:30
Added on [2014-02-21 Fri 16:28].

=org-mode-line-clock= is defined through =org-copy-face= as inheriting
from =mode-line=.  However, that's not what I want, because it gets
the "mode line active" face even in inactive buffers.
#+BEGIN_SRC emacs-lisp
  (eval-after-load "org-faces"
    '(set-face-attribute 'org-mode-line-clock nil
                         :inherit nil))
#+END_SRC
* Update mode line face on focus
Added on [2014-02-21 Fri 16:45].
#+BEGIN_SRC emacs-lisp
  (defvar my-mode-line-active-background "gray75")
  (defvar my-mode-line-inactive-background "gray40")
  
  (defun my-unhighlight-mode-line ()
    (set-face-attribute 'mode-line nil
                        :background my-mode-line-inactive-background))
  
  (add-hook 'focus-out-hook 'my-unhighlight-mode-line)
  
  (defun my-highlight-mode-line ()
    (set-face-attribute 'mode-line nil
                        :background my-mode-line-active-background))
  
  (add-hook 'focus-in-hook 'my-highlight-mode-line)
#+END_SRC
* Always save buffer text before reverting (saves lives!)
#+BEGIN_SRC emacs-lisp
  (defun maybe-save-before-reverting ()
    (unless (or (bound-and-true-p auto-revert-mode)
                (bound-and-true-p auto-revert-tail-mode))
      (kill-new (buffer-string))
      (message "Previous buffer text saved to kill ring")))
  (add-hook 'before-revert-hook 'maybe-save-before-reverting)
#+END_SRC
* escript zip support for archive-mode				     :erlang:
Added on [2014-05-23 Fri 18:26].
#+BEGIN_SRC emacs-lisp
  (defvar archive-escript-zip-hook nil)

  (defun archive-escript-zip--narrow ()
    (widen)
    (goto-char (point-min))
    (search-forward-regexp "^\\(PK00\\)?[P]K\003\004")
    (narrow-to-region (match-beginning 0) (point-max)))

  (defun archive-escript-zip-summarize ()
    (archive-escript-zip--narrow)
    (archive-zip-summarize))

  (defun archive-escript-zip-extract (_archive name)
    (let ((temp-file (make-temp-file "escript-archive" nil ".zip"))
          (coding-system-for-write 'binary))
      (unwind-protect
          (progn
            (with-current-buffer archive-superior-buffer
              (save-restriction
                (widen)
                (write-region archive-proper-file-start
                              (point-max)
                              temp-file nil :silent)))
            (archive-zip-extract temp-file name))
        (delete-file temp-file))))

  (defun archive-escript-zip-find-type (old-fun)
    (widen)
    (goto-char (point-min))
    (let (case-fold-search)
      (cond
       ((and (looking-at "#!.*escript")
             (search-forward-regexp "^\\(PK00\\)?[P]K\003\004" nil t))
        'escript-zip)
       (t
        (funcall old-fun)))))

  (with-eval-after-load "arc-mode"
    (advice-add 'archive-find-type :around #'archive-escript-zip-find-type))

  (defun archive-escript-zip--maybe-turn-on ()
    (require 'arc-mode)
    (save-excursion
      (save-restriction
        (when (eq (ignore-errors (archive-find-type)) 'escript-zip)
          (run-with-idle-timer
           0.1 nil
           (lambda (buffer)
             (with-current-buffer buffer
               (archive-mode)))
           (current-buffer))))))

  (with-eval-after-load "erlang"
    (add-hook 'erlang-mode-hook 'archive-escript-zip--maybe-turn-on))
#+END_SRC
* Avoid "ControlPath too long" with Tramp on OSX
Added on [2014-06-19 Thu 14:51].

For some reason, the function =tramp-compat-temporary-file-directory=
disregards any customization for =temporary-file-directory=, and
always goes with the _standard_ value.  On OSX, the standard value is
likely to be fairly long, but =/tmp= is equivalent to it anyway:
#+BEGIN_SRC emacs-lisp
  (put 'temporary-file-directory 'standard-value (list "/tmp/"))
#+END_SRC
* Avoid CFGERR disabling Flymake				    :flymake:
Added on [2014-06-30 Mon 12:18].

Adapted from http://debbugs.gnu.org/cgi/bugreport.cgi?bug=2491.

If a Flymake compilation fails, but there are no error messages for
the file being compiled (i.e., all errors are in included files), then
Flymake will switch itself off and say:

#+BEGIN_QUOTE
switched OFF Flymake mode for buffer foo.erl|src due to fatal status CFGERR
#+END_QUOTE

This change makes it just display =:CFGERR= in the mode line, without
deactivating Flymake.

#+BEGIN_SRC emacs-lisp
  (require 'cl-lib)
  (defun my-flymake-cfgerr-is-benign (orig-fun &rest args)
    "Don't let `flymake-post-syntax-check' deactivate Flymake.
  As described in http://debbugs.gnu.org/cgi/bugreport.cgi?bug=2491,
  CFGERR errors can be benign conditions."
    ;; Using `cl-letf' as a kind of temporary advice.
    (cl-letf (((symbol-function 'flymake-report-fatal-status)
               (lambda (_status _warning)
                 (flymake-report-status "0/0" ":CFGERR"))))
      (apply orig-fun args)))

  (with-eval-after-load "flymake"
    (advice-add 'flymake-post-syntax-check :around 'my-flymake-cfgerr-is-benign))

#+END_SRC
* No =nroff-mode= for =*.[1-9]=
Added on [2014-08-26 Tue 11:33].

I never open nroff files, but often open log files matching this
pattern.  The nroff-mode font locking slows scrolling down
considerably, so I prefer fundamental-mode for these.

#+BEGIN_SRC emacs-lisp
  (setq auto-mode-alist (delete '("\\.[1-9]\\'" . nroff-mode) auto-mode-alist))
#+END_SRC
* Add Dvorak layout to quail-keyboard-layout-alist
Added on [2014-10-31 Fri 12:41].

This makes it possible to use input methods that emulate a different
keyboard layout, such as ะะฆะฃะะะ.
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "quail"
    (let ((dvorak-layout
           (concat "                              "
                   "  1!2@3#4$5%6^7&8*9(0)[{]}`~  "
                   "  '\",<.>pPyYfFgGcCrRlL/?=+    "
                   "  aAoOeEuUiIdDhHtTnNsS-_\\|  "
                   "    ;:qQjJkKxXbBmMwWvVzZ      "
                   "                                "))
          (current-entry (assoc "dvorak" quail-keyboard-layout-alist)))
      (if current-entry
          (setf (cdr current-entry) dvorak-layout)
        (push (cons "dvorak" dvorak-layout) quail-keyboard-layout-alist))))
  (quail-set-keyboard-layout "dvorak")
#+END_SRC
